#!
# maillogstats.py
#
# Collects statistics on a maillog file generated by sendmail or postfix.
# Usage:
"""
maillogstats.py [OPTIONS] filename
	If no options are specified, shows statistics from the previous 24 hour period.

	Options:
		-h|--help		Prints this help message

		--nagios		Provides output that Nagios can read and interpret

		-o|--output		Write the report output to the specified file

		-p|--period		specify #d, #h, #m
						i.e. 5d, 10m, 4h
						Specifies the time period to report statistics back
						Assumes current time minus the value specified, for 
						example 5m would mean to report statistics on the time
						range between now and 5 minutes before the current time.

		-v|--verbose	verbose output"""

import sys
import re
from datetime import datetime
from datetime import date
from datetime import timedelta

verbose = False

def main():
	"""Main function"""
	global verbose

	# options that will be set by command line arguments
	nagios_output = False
	out_file = ''
	period = ''

	input_lines = []

	# check for verbose output option
	if "-v" in sys.argv:
		verbose = True
	
	# parse arguments
	debug_out('Number of arguments: ' + str(len(sys.argv)))
	debug_out('Argument List:' + str(sys.argv))

	for index,arg in enumerate(sys.argv):
		if arg == '-h' or arg == '--help':
			print_help()
			sys.exit(0)
		elif arg == '--nagios':
			nagios_output = True
		elif arg == '-p' or arg == '--period':
			period = sys.argv[index + 1]
		elif arg == '-o' or arg == '--output':
			out_file = sys.argv[index + 1]

	# if period is empty after checking options, set it to 24h
	if len(period) == 0:
		period = '24h'

	# get input file name, it should be the last argument, attempt to open the file for reading
	input_file_name = sys.argv[len(sys.argv) - 1]
	debug_out('Opening file for read: ' + input_file_name)

	input_file = open(input_file_name, "r")
	input_data = parse_file(input_file, period)
	input_file.close()

	debug_out('Lines in extracted data: ' + str(len(input_data)))

	# call the period report function
	period_report(input_data, nagios_output, out_file)

def period_report(inp, nag, out):
	"""produces the report given period, nagios output, and output file parameters"""
	debug_out('Parameters passed to period_report: nag = ' + str(nag) + ' out = ' + out)
	messages = message_table(inp)
	
def parse_file(filehandle, per):
	"""generates a table of data from the file"""
	m = re.search(r"(?P<value>\d+)(?P<unit>[dhm])", per)

	period_unit = m.group('unit')
	period_value = m.group('value')
	debug_out('period_unit = ' + period_unit + ' period_value = ' + period_value)

	# perform the date calculation to get the date range
	end_date = datetime.today()
	end_date = datetime(2014, 02, 16, 04, 02, 50) # comment this out, for testing only
	# create the timedelta object
	if period_unit == 'd':
		delta = timedelta(days=int(period_value))
	elif period_unit == 'h':
		delta = timedelta(hours=int(period_value))
	elif period_unit == 'm':
		delta = timedelta(minutes=int(period_value))
	# finally, calculate the start date
	start_date = end_date - delta
	debug_out('start_date = ' + str(start_date) + ' end_date = ' + str(end_date))

	# find the row range to work with
	lines = find_line_range(filehandle, start_date, end_date)

	# table columns: 
	# datetime, hostname, application, message
	regexp_normal = r"\d+:\d+:\d+\s(?P<hostname>\S+)\s(?P<application>\S+):\s(?P<message>.+)" # normal case
	regexp_no_application = r"\d+:\d+:\d+\s(?P<hostname>\S+)\s(?P<message>.+)"
	log_reg = re.compile(regexp_normal)
	log_reg_no_app = re.compile(regexp_no_application)
	file_data = []
	for index,line in enumerate(lines):
		match = log_reg.search(line)
		# second case, no application, just system logging information
		if match == None:
			match = log_reg_no_app.search(line)
		# exit with error message if match is None
		if match == None:
			debug_out('parse_file failed, non-matching line: ' + line)
			sys.exit(1)
		match_dict = match.groupdict()
		if 'application' not in match_dict:
			match_dict['application'] = ''
		row = {
				'datetime': entry_datetime(line), 
				'hostname': match_dict['hostname'], 
				'application': match_dict['application'],
				'message': match_dict['message'],
				}
		#print row
		file_data.append(row)

	debug_out('start_row = ' + str(file_data[0]))
	debug_out('end_row = ' + str(file_data[len(file_data) - 1]))

	return file_data

def find_line_range(fh, start, end):
	"""finds the index of the first row matching the time of the start parameter and the last row matching the 
	end parameter"""

	lines = []

	for index, line in enumerate(fh):
		#print str(index) + ": " + str(row)	
		line_date = entry_datetime(line)
		if line_date > end:
			break	
		if line_date >= start and line_date <= end:
			lines.append(line)

	return lines

def entry_datetime(string):
	"""returns a date object with the date and time the line provided was logged"""
	today = date.today()
	month_table = {'Jan': 1,
					'Feb': 2,
					'Mar': 3,
					'Apr': 4,
					'May': 5,
					'Jun': 6,
					'Jul': 7,
					'Aug': 8,
					'Sep': 9,
					'Oct': 10,
					'Nov': 11,
					'Dec': 12}

	regexp = r"(?P<month>^[A-Z][a-z][a-z])\s{1,2}?(?P<day>\d+)\s(?P<hour>\d+):(?P<minute>\d+):(?P<second>\d+)"

	match = re.search(regexp, string)

	month = match.group('month')
	day = match.group('day')
	hour = match.group('hour')
	minute = match.group('minute')
	second = match.group('second')

	#debug_out('Entry date and time: ' + month + " " + day + " " + hour + ':' + minute + ':' + second)

	# check for special case on new year's day
	month_number = month_table[month]
	if today.month == 1 and month_number == 12:
		year = today.year - 1
	else:
		year = today.year

	parsed_date = datetime(year, month_number, int(day), int(hour), int(minute), int(second))
	return parsed_date


def message_table(data):
	"""takes parsed log entries from the database and creates a message table"""


def debug_out(string):
	"""deals with printing a string to stdout, only prints if the global variable verbose is true"""
	global verbose
	if verbose:
		print string

def print_help():
	"""prints the help message and exits"""
	print """
		maillogstats.py [OPTIONS] filename
		If no options are specified, shows statistics from the previous 24 hour period.
		Options:
			-h|--help		Prints this help message

			--nagios		Provides output that Nagios can read and interpret

			-o|--output		Write the report output to the specified file

			-p|--period		specify #d, #h, #m
							i.e. 5d, 10m, 4h, etc.
							Specifies the time period to report statistics back
							Assumes current time minus the value specified, for 
							example 5m would mean to report statistics on the time
							range between now and 5 minutes before the current time.

			-v|--verbose	verbose output"""
	sys.exit(0)

if __name__ == "__main__":
	main()

"""It is easier to deal with the message parsing in a single object"""
class MaillogParser(object):
	"""
	Interesting messages:
	Feb 16 04:02:02 crabeater postfix/cleanup[17046]: 429161399EDB: hold: header Received: from vcs.ccom.nh (vcs.ccom.unh.edu [192.168.3.12])??(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))??(No client certificate requested)??by mail.ccom.unh.edu (Postfix) with ESMTP  from vcs.ccom.unh.edu[192.168.3.12]; from=<root@vcs.ccom.nh> to=<jchadwick@ccom.unh.edu> proto=ESMTP helo=<vcs.ccom.nh>
	Feb 16 04:02:03 crabeater MailScanner[16861]: Requeue: 429161399EDB.ABC8F to 1EA5B139A83E 
	Feb 16 04:02:03 crabeater postfix/local[17053]: 1EA5B139A83E: to=<jchadwick@ccom.unh.edu>, relay=local, delay=1.6, delays=1.6/0/0/0.01, dsn=2.0.0, status=sent (delivered to mailbox)
	Feb 13 09:24:27 crabeater postfix/local[23883]: D3445139A822: to=<dhoriuchi@ccom.unh.edu>, orig_to=<gebco@ccom.unh.edu>, relay=local, delay=3.4, delays=3.4/0/0/0.02, dsn=2.0.0, status=sent (delivered to mailbox)
	Feb 14 13:04:23 crabeater postfix/smtp[30393]: 62A13139A83B: to=<david.berlinsky@unh.edu>, relay=jaffrey.unh.edu[132.177.137.62]:25, delay=11, delays=2.6/0/6/2.4, dsn=2.0.0, status=sent (250 2.0.0 s1EI4K7p018920 Message accepted for delivery)
	Feb 14 12:48:06 crabeater MailScanner[29752]: Found phishing fraud from http://deals.tasteoftheseacoast.com claiming to be www.gotodeals.tasteoftheseacoast.com in 45D7E139A822.AB235
	Mar 17 14:10:31 crabeater postfix/local[12419]: 02AE9139A840: to=<cparrish@ccom.unh.edu>, relay=local, delay=25, delays=25/0/0/0.05, dsn=5.2.2, status=bounced (cannot update mailbox /var/spool/mail/cparrish for user cparrish. error writing message: File too large)
	Mar 17 15:44:00 crabeater postfix/smtpd[17232]: 16AA0139A822: reject: RCPT from p3021-ipbffx02koufu.yamanashi.ocn.ne.jp[60.38.60.149]: 554 5.7.1 <seminar@ccom.unh.edu>: Recipient address rejected: Access denied; from=<alienation560@rbnsn.com> to=<seminar@ccom.unh.edu> proto=ESMTP helo=<p3021-ipbffx02koufu.yamanashi.ocn.ne.jp>
	Feb 14 01:49:14 crabeater MailScanner[30723]: Spam Checks: Found 1 spam messages
	May 21 13:49:00 crabeater postfix/smtpd[16843]: NOQUEUE: reject: RCPT from unknown[68.142.129.98]: 450 4.7.1 <Maxs-Xserve.local>: Helo command rejected: Host not found; from=<_www@Maxs-Xserve.local> to=<monahandk@ccom.unh.edu> proto=ESMTP helo=<Maxs-Xserve.local>

	"""

	message_regexp_db = {
		'hold header': 				r"^(?P<message_id>[0-9A-F]+):\shold:\sheader\sReceived:.+\((?P<mta_name>\S+)\s\[(?P<mta_ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\].+from=<(?P<sender>\S+\@\S+)>\sto=<(?P<recipient>\S+\@\S+)>",
		'requeue': 					r"^Requeue:\s(?P<message_id>[0-9A-F]+)\.[0-9A-F]+\sto\s(?P<new_id>[0-9A-F]+)",
		'local delivery': 			r"^(?P<message_id>[0-9A-F]+):\sto=<(?P<recipient>\S+@\S+)>,\srelay=local,\sdelay=(?P<delay>[0-9.]+).+status=(?P<status>\w+)\s",
		'local delivery - aliased': r"^(?P<message_id>[0-9A-F]+):\sto=<(?P<recipient>\S+@\S+)>,\sorig_to=<(?P<recipient_alias>\S+@\S+)>,\srelay=local,\sdelay=(?P<delay>[0-9.]+).+status=(?P<status>\w+)\s",
		'remote delivery':			r"^(?P<message_id>[0-9A-F]+):\sto=<(?P<recipient>\S+@\S+)>,\srelay=(?P<mta_name>\w+)\[(?P<mta_ip>[0-9.]+)\],\sdelay=(?P<delay>[0-9.]+).+status=(?P<status>\w+)\s",
		'phishing':					r"^Found phishing fraud from ",
		
	}

	def __init__(self):
		"""constructor"""
		self.messages = []
		self.last_match = None

	def line_match(self, row, app):
		"""parses the row given the application"""
		for desc, reg in message_regexp_db:
			m = re.match(reg, row['message'])
			if m != None:
				if desc == 'requeue':
					self.requeue(match)
					return 1
				else:
					self.insert_message(m)

	def insert_message(self, match):
		"""inserts a new message"""
		msg = Message()
		mdict = match.groupdict()
		for k,v in mdict:
			msg.set(k, v)
		self.messages.append(msg)

	def requeue(self, match):
		"""deals with a requeue"""
		try:
			new_id = match.group('new_id')
		except IndexError:
			# not a requeue, carry on
			return False

		# find the old id, and update
		old_id = match.group('message_id')
		for message in self.messages:
			if message.message_id == old_id:
				message.requeue(new_id)



class Message(object):
	'''A class that encapsulates properties of messages'''
	# message_id, mta_name, mta_ip, sender, recipient, delay, size, status

	def __init__(self):
		'''constructor'''
		self.message_id = ''
		self.mta_name = ''
		self.mta_ip = ''
		self.sender = ''
		self.recipient_alias = ''
		self.recipient = ''
		self.delay = ''
		self.size = ''
		self.status = ''
		self.url = ''

		self.old_ids = []

	def requeue(self, new_id):
		'''deals with the requeing of messages with new IDs'''
		self.old_ids.append(self.message_id)
		self.message_id = new_id

	def set(self, key, value):
		'''sets the value of a key in the structure'''
		if key == 'message_id':
			self.message_id = value
		elif key == 'mta_name':
			self.mta_name = value
		elif key == 'mta_ip':
			self.mta_ip = value
		elif key == 'sender':
			self.sender = value
		elif key == 'recipient':
			self.recipient = value
		elif key == 'delay':
			self.delay = value
		elif key == 'size':
			self.size = value
		elif key == 'status':
			self.status = value